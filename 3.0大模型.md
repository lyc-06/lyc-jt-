# JoTangLM3.0大模型—交互页面制作过程
## 1. 页面结构设计
- 侧边栏(顶部logo、新建对话按钮及对话列表、个性化设置)
- 主体内容区（输入框、输出框、模式切换按钮）
  
## 2. 侧边栏样式设计
### 2.1 顶部logo固定
设置顶部logo样式，包括居中、大小、颜色等，在logo下方添加一条实线分割线。
```css
.sidebar-header {
            height: var(--header-height);
            display: flex;
            align-items: center;
            padding: 0 1rem;
            border-bottom: 1px solid #e5e7eb;/* 在logo底部设计实线边框 */
        }

        .logo {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
        }
```
### 2.2 侧边栏样式
在侧边栏右侧设计实线边框，增加阴影，使得侧边栏有浮起来的感觉。
```css
 border-right: 1px solid #e5e7eb;/* 在右侧设计实线边框 */
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1); /* 添加阴影 */
 ```

 ### 2.3 新建对话按钮
 设置新建对话按钮样式，包括大小、颜色、边框等，并添加鼠标悬浮样式。
 ```css
 .new-chat-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;/* 圆角 */
            font-weight: 600;
            cursor: pointer;/* 鼠标指针 */
            margin-bottom: 1rem;
            width: 100%;
        }
```
### 2.4 聊天列表样式
- 设置聊天列表样式，包括背景色、字体颜色、字体大小、边框等。
- 设置鼠标悬停时颜色改变。
```css
.chat-item:hover {
            background-color: #f3f4f6;/* 鼠标悬停时，背景颜色改变为一种淡灰色 */
        }
```
- 设置选中某个聊天时，背景颜色固定，突出显示。
```css
.chat-item.active {
            background-color: #e9e3ff;/* 选中时，背景颜色改变为一种灰色 */
        }
```

### 2.5 删除聊天按钮样式
- 默认隐藏，当鼠标悬浮在聊天列表上时，显示删除按钮。
  ```css
  .delete-chat {
            visibility: hidden;/* 默认隐藏 */
            cursor: pointer;/* 鼠标指针 */
        }

        .chat-item:hover .delete-chat {
            visibility: visible;/* 鼠标悬停时，显示删除按钮 */
        }
  ```
### 2.6 侧边栏底部设置区样式
- 设置按钮样式，包括大小、颜色、边框、鼠标悬浮效果等，并按照页面设计规律，将文字左对齐。
  ```css
   text-align: left;/* 文本左对齐 */
  ```
```css
.settings-btn:hover {
            background-color: #f3f4f6;/* 鼠标悬停时，背景颜色改变为一种淡灰色 */
            border-radius: 0.375rem;
        }
```
- 设置弹窗及其内容样式，包括背景色、字体颜色、字体大小、边框等，并通过设置其余部分的背景颜色和透明度，凸显设置窗口 
```css
background-color: rgba(0,0,0,0.4);
```
- 设置弹窗关闭按钮样式。
 
## 3. 主体内容区样式设计
### 3.1 输入框样式设计
- 设置输入框基本样式。
- 固定输入框高度，使得内容过多时出现滚动条，而不是无限增大。
  ```css
  overflow: hidden; /* 隐藏滚动条 */
    resize: none; /* 禁用用户调整大小 */
    min-height: 40px; /* 设置最小高度 */
    max-height: 80px; /* 设置最大高度 */
  ```
### 3.2 输出框样式设计
- 定义聊天消息的外观样式，包括最大宽度、上下文间距、内边距、圆角效果和行高设置。
```css

        .message {
            max-width: 80%;
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 0.5rem;
            line-height: 1.5;
        }
```
- 将用户消息右对齐，AI回复左对齐。
  ```css
   .user-message {
            align-self: flex-end;/* 右对齐 */
            background-color: var(--primary-color);
            color: white;
        }

        .ai-message {
            align-self: flex-start;/* 左对齐 */
            background-color: #e5e7eb;
        }
  ```  

### 3.3 模式切换按钮
- 设置背景颜色、圆角、鼠标悬浮等效果。
  ```css
   .mode-button {
    background-color: var(--primary-color); /* 默认背景色 */
    color: white; /* 文字颜色 */
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  .mode-button:hover {
    background-color: #7a4fcf; /* 鼠标悬停时的默认颜色 */
  }
  ```

## 4. script函数设置
### 4.1 切换两种回答模式  (toggleMode函数)
```javascript
        function toggleMode() {
          currentMode = currentMode === 'concise' ? 'professional' : 'concise';//如果 currentMode 的值是 'concise'（简洁模式），那么它会将 currentMode 的值更改为 'professional'（专业模式）。
  const modeToggleButton = document.getElementById('mode-toggle');// 获取模式切换按钮的 DOM 元素
  modeToggleButton.textContent = currentMode === 'concise' ? '简洁模式' : '专业模式';// 根据当前模式，更新按钮的文本内容:如果 currentMode 是 'concise'，那么按钮的文本将显示为 '简洁模式'。如果当前模式是 'professional'，那么按钮将显示为 '专业模式'。
  }
```

### 4.2 本地存储
```javascript
 // 本地存储
        function loadChats() {
            const savedChats = localStorage.getItem('chats');// 从localStorage获取保存的聊天记录
            if (savedChats) {// 如果上一步获取的 savedChats 存在,即有保存的聊天记录，进入if语句
                chats = JSON.parse(savedChats);//使用 JSON.parse 方法将获取到的字符串格式的聊天记录转换为 JavaScript 对象，并赋值给 chats 变量。
                updateChatList();//更新界面上的聊天列表，以便在加载新记录后显示它们。
            }
        }

        // 将聊天记录（存储在 chats 数组中）保存到浏览器的本地存储中，以便在用户刷新页面或关闭浏览器后，能够恢复之前的聊天记录。
        function saveChats() {
            localStorage.setItem('chats', JSON.stringify(chats));
        }
```

### 4.3 新建聊天
```javascript
//新建聊天
function createNewChat() {
    const chatId = Date.now();//获取当前时间截，生成一个唯一的 ID 作为对话的标识符
    const chat = {
        id: chatId,  //唯一标识符，来自前面的时间戳。
        name: `对话 ${chats.length + 1}`,//聊天的名称，格式为“对话 n”，其中 n 是当前 chats 数组中已有会话的数量加一。
        messages: [],
        index: chats.length + 1 // 设置序号
    };
    
    chats.push(chat);//将新创建的聊天对象 chat 添加到 chats 数组中，chats 数组用于存储所有的聊天会话。
    currentChatId = chatId;//将 currentChatId 更新为当前新建聊天的 ID，以便后续操作可以在这个上下文中进行。
    updateChatList();//调用 updateChatList() 函数，重新渲染聊天列表界面，以使新创建的聊天可见。
    clearChatContainer();//调用 clearChatContainer() 函数，清空当前聊天显示区域，以便为新聊天做准备。
    saveChats();//调用 saveChats() 函数将当前的聊天会话信息保存到本地存储中，
}
```
### 4.4 更新聊天列表
```javascript
//更新聊天列表的显示
function updateChatList() {
    const chatList = document.getElementById('chat-list');//将 chatList 的内容清空，这样可以确保我们每次更新聊天列表时都从一个空白状态开始，避免旧的聊天项内容残留。
    chatList.innerHTML = '';
    const newColor = document.getElementById('theme-color').value; // 获取一个 input 元素的值，该元素允许用户选择主题颜色。
    chats.forEach(chat => {//循环,对于每个聊天对象，以下操作都会执行。
        const chatItem = document.createElement('div');
        chatItem.className = `chat-item ${chat.id === currentChatId ? 'active' : ''}`;//chatItem 的类名被设置为 chat-item。同时，使用模板字符串，判断当前聊天的ID是否与当前激活的聊天ID相同。如果相同，就会给这个聊天项添加额外的类名 active，从而可以使用CSS样式来突出显示当前选中的聊天项。
        //div和span元素
        chatItem.innerHTML = `
            <div class="chat-item-content" onclick="switchChat(${chat.id})"> 
                <div class="chat-item-icon"></div> 
                <div class="chat-item-name">${chat.name}</div>
            </div>
            <span class="delete-chat" onclick="deleteChat(${chat.id})">🗑️</span>
        `;
        chatList.appendChild(chatItem);//将创建的 chatItem 添加到 chatList 中，使其显示在用户界面上。
    });
}
```
### 4.5 切换聊天
```javascript
//切换当前聊天会话
function switchChat(chatId) {
            currentChatId = chatId;//更新当前聊天的ID
            clearChatContainer();//调用 clearChatContainer() 函数，清空当前聊天内容显示区域。
            const chat = chats.find(c => c.id === chatId);//使用 find 方法从 chats 数组中找到与提供的 chatId 匹配的聊天对象。
            document.getElementById('current-chat-title').textContent = chat.name;//将找到的聊天对象的名称（chat.name）设置为界面上当前聊天标题的文本内容。
            chat.messages.forEach(msg => addMessageToChat(msg.text, msg.sender));
            updateChatList();//调用 updateChatList() 函数，以更新聊天列表的状态
        }
```
### 4.6 删除聊天
```javascript
/删除特定聊天对话
        function deleteChat(chatId) {
    const index = chats.findIndex(c => c.id === chatId);
    if (index > -1)   { //检查找到的索引是否有效（即是否存在）。如果 index 大于 -1，表示成功找到要删除的聊天。
        chats.splice(index, 1);//index 是要删除元素的起始位置，1 是要删除的元素个数。
    }
        }
```
### 4.7 删除对话后列表序号重新排列
```javascript
 // 删除聊天会话后,重新排序序号
        chats.forEach((chat, idx) => {
            chat.index = idx + 1; // 更新序号从1开始
            chat.name = `对话 ${idx + 1}`; // 更新名称以反映新的顺序
        });
        if (currentChatId === chatId) {//如果当前活动聊天的 ID（currentChatId）等于被删除聊天的 ID（chatId），则需要处理当前活动聊天的更新。
            currentChatId = chats.length > 0 ? chats[chats.length - 1].id : null;//将 currentChatId 更新为当前聊天列表的最后一个聊天的 ID，若聊天列表为空，则设置为 null。
            if (currentChatId) {
                switchChat(currentChatId);//如果 currentChatId 仍然有效（即存在聊天），调用 switchChat() 切换到该聊天。
            } else {
                clearChatContainer();
                document.getElementById('current-chat-title').textContent = '新对话';//如果没有有效的聊天，调用 clearChatContainer() 清空聊天显示区域，并将当前聊天标题设置为“新对话”。
            }
        }
        updateChatList();//调用 updateChatList() 函数，以更新聊天列表的状态。
        saveChats();//调用 saveChats() 函数将当前的聊天会话信息保存到本地存储中。
  ```
  ### 4.8 固定输入框高度，自适应出现滚动条
  ```javascript
  //实现一个自适应高度的文本输入框
        function autoResizeTextarea() {
    const textarea = document.getElementById('user-input');//使用 document.getElementById 方法获取具有 ID user-input 的文本区域元素，并将其赋值给变量 textarea。这允许以后对该文本区域进行操作。
    textarea.style.height = 'auto'; // 先重置为“自动”以计算真实高度
    const newHeight = Math.min(textarea.scrollHeight, 100); // 计算当前高度，并使用 Math.min() 方法限制最大高度为 100px
    textarea.style.height = `${textarea.scrollHeight}px`; // 将文本区域的高度设置为计算出的新高度，确保文本区域可以完全显示所有文本内容。
}
document.getElementById('user-input').addEventListener('input', autoResizeTextarea);//为ID为user-input的文本输入框添加了一个input事件监听器。当用户在输入框中输入内容时，autoResizeTextarea函数将被调用。
  ```

### 4.9 将消息添加到页面
```javascript
//将消息添加到页面
function addMessageToChat(text, sender) {
            const chatContainer = document.getElementById('chat-container');//获取聊天内容显示区域的 DOM 元素，并将其赋值给变量 chatContainer。
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;//设置 messageDiv 的 className 属性。这使得该消息具有基本的样式以及发送者的样式，形式如 message user-message 或 message ai-message，具体取决于消息的发送者。
            messageDiv.textContent = text;
            chatContainer.appendChild(messageDiv);//使用 appendChild 方法将 messageDiv 添加到 chatContainer 中，这样用户就能在聊天界面上看到该消息。
            chatContainer.scrollTop = chatContainer.scrollHeight;//使得聊天容器自动向下滚动
        }        
```
### 4.10 回车键发送消息
```javascript
/*用户按下回车键时触发发送消息*/
        function handleKeyPress(event) {
            if (event.key === 'Enter') {//判断用户按下的键是否是“回车”键。
                sendMessage();//如果是，则调用 sendMessage() 函数发送消息。
            }
        }    
```
### 4.11 输入框提示消息
```javascript
/*聚焦输入框时移除提示信息，失焦时恢复提示信息*/
        function clearPlaceholder() {
    const userInput = document.getElementById('user-input');
    userInput.placeholder = ''; // 清空占位符
}
function restorePlaceholder() {
    const userInput = document.getElementById('user-input');
    if (!userInput.value) { // 如果内容为空，则恢复占位符
        userInput.placeholder = '输入您的问题...';
    }
}
```
### 4.12 发送消息
```javascript
//发送消息
function sendMessage() {
            const userInput = document.getElementById('user-input');
            const message = userInput.value.trim();
            if (message && currentChatId) {//检查 message 是否非空（即用户是否输入了内容）并且当前聊天会话 ID (currentChatId) 是否有效。如果两个条件都满足，才会继续执行后续的逻辑。
                addMessageToChat(message, 'user');//调用 addMessageToChat() 函数将用户输入的内容添加到聊天界面上，并标记为用户发送的消息。
                const currentChat = chats.find(c => c.id === currentChatId);//在 chats 数组中查找当前活动聊天会话，将找到的聊天对象赋值给 currentChat 变量。
                currentChat.messages.push({ text: message, sender: 'user' });//将用户的消息文本及其发送者信息以对象的形式保存到 currentChat.messages 数组中，以便后续查阅。
  
                userInput.value = '';//清空用户输入框的内容。
               // 模拟 AI 回复
                setTimeout(() => {//使用 setTimeout 函数以 1000 毫秒（1 秒）的延迟来模拟 AI 的反应时间。
    const aiResponse = generateAIResponse(message, currentChat.context, currentMode);//调用 generateAIResponse 函数，传入用户消息、当前聊天上下文和当前模式（如简洁或专业模式），来生成 AI 的响应。

    addMessageToChat(aiResponse, 'ai');//将 AI 生成的响应添加到聊天界面，使用 addMessageToChat 函数，第二个参数为 'ai' 表示消息来源为 AI。
    currentChat.messages.push({ text: aiResponse, sender: 'ai' });//将 AI 的消息也记录在 currentChat.messages 数组中。

    
    updateContext(currentChat, aiResponse);//调用 updateContext() 函数，更新当前聊天的上下文。
    
    saveChats();//调用 saveChats() 函数将当前的聊天会话信息保存到本地存储中。
  }, 1000);
            }
        }
```
### 4.13 生成不同模式下的 AI 响应
```javascript
// 生成AI的响应
        function generateAIResponse(userMessage, context, mode) {
  const responses = {//创建一个名为 responses 的对象，用于存储不同模式下的响应模板。
    // 简洁模式
    concise: [
      {
        keywords: ["你好", "嗨", "您好"],
        templates: [
          "你好!",
          "您好!",
          "嗨!"
        ]
        },
        ......
    ]
      
      // 专业模式
    professional: [
      {
        keywords: ["你好", "嗨", "您好"],
        templates: [
          "您好!很高兴为您提供专业服务。请问您今天有什么具体的问题或需求吗?",
          "您好!欢迎使用我们的专业咨询服务。我们可以就任何专业话题进行深入讨论。",
          "您好!作为您的专业助手,我随时准备为您解答各种复杂问题。请问您需要哪方面的帮助?"
        ]
      },
      ......
    ]
  }
        }
```
### 4.14 看是否匹配关键词
```javascript
// 查找匹配的关键词响应
  for (let response of responses[mode]) {// 遍历响应列表
    // 如果用户消息包含关键词,返回对应的响应
    if (response.keywords.some(keyword => userMessage.toLowerCase().includes(keyword))) {
      return response.templates[Math.floor(Math.random() * response.templates.length)];
    }
  }

  // 如果没有匹配的关键词,使用默认响应
  const defaultResponses = {
    concise: [
      `简单说说"${userMessage}"吧。`,
      `"${userMessage}"，您觉得呢?`,
      `关于"${userMessage}"，您的想法是?`
    ],
    professional: [
      `您提到的"${userMessage}"是一个很有深度的话题。从专业角度来看,这涉及到多个方面的考量。我们可以从理论基础、实际应用和未来发展三个维度来讨论。您想先探讨哪个方面?`,
      `"${userMessage}"这个话题在学术界一直有许多争议。不同的研究方法和理论框架会导致不同的结论。您对这个话题有什么特定的研究兴趣吗?我们可以深入探讨相关的学术文献。`,
      `关于"${userMessage}",这是一个跨学科的研究领域。我们需要结合心理学、社会学、经济学等多个学科的知识来全面理解。您对哪个具体的研究方向感兴趣?我可以为您提供相关的专业见解。`
    ]
  };

  return defaultResponses[mode][Math.floor(Math.random() * defaultResponses[mode].length)];//根据当前模式，随机选择一个默认响应进行返回
```

### 4.15 设置模态框的显示和隐藏
```javascript
//打开设置模态框（弹出窗口）
        function openSettings() {
            document.getElementById('settings-modal').style.display = 'block';//默认情况下，display属性是none（隐藏状态），而设置为block则显式使其显示出来。
        }
//关闭设置模态框
        function closeSettings() {
            document.getElementById('settings-modal').style.display = 'none';//设置display属性为none，则隐藏设置模态框。
        }
```
### 4.16 选择新的主题颜色
```javascript
// 选择新的主题颜色    
        function changeThemeColor() {
    const newColor = document.getElementById('theme-color').value; // 获取用户选择的颜色
    document.documentElement.style.setProperty('--primary-color', newColor); // 更新主颜色
```
### 4.17 设置模式更改按钮颜色变深的效果
```javascript
// 设置鼠标在更改模式的按钮悬停时的颜色
    const modeToggleButton = document.getElementById('mode-toggle');
    modeToggleButton.onmouseover = function() {
        modeToggleButton.style.backgroundColor = shadeColor(newColor, -20); // 调用shadeColor函数，深色处理-20（稍微变深）
    };

    modeToggleButton.onmouseout = function() {
        modeToggleButton.style.backgroundColor = newColor; // 恢复正常颜色
    };
}

// 实现颜色变深的函数（该函数的主要功能是根据输入的十六进制颜色及变化百分比生成一个新的颜色值，）
function shadeColor(color, percent) {
    const R = parseInt(color.slice(1, 3), 16);
    const G = parseInt(color.slice(3, 5), 16);
    const B = parseInt(color.slice(5, 7), 16);

    return `#${((1 << 24) + (Math.min(255, R + R * (percent / 100)) << 16) 
           + (Math.min(255, G + G * (percent / 100)) << 8) 
           + Math.min(255, B + B * (percent / 100)))
           .toString(16).slice(1)}`;
}
```
### 4.18 改变字体大小
```javascript
//改变网页字体的大小
        function changeFontSize() {
            const size = document.getElementById('font-size').value;
            document.body.style.fontSize = size + 'px';//设置以像素为单位的字体大小。
            document.getElementById('font-size-value').textContent = size + 'px';//更新显示字体大小的标签。
            localStorage.setItem('fontSize', size);//保存字体大小设置
        }
```
### 4.19 保存和加载个性化设置
```javascript
// 加载保存的设置
        function loadSettings() {
            const savedColor = localStorage.getItem('themeColor');//读取保存的主题颜色
            if (savedColor) {//如果有保存的主题颜色，则设置主题颜色选择框的值
                document.getElementById('theme-color').value = savedColor;
                document.documentElement.style.setProperty('--primary-color', savedColor);
            }

            const savedFontSize = localStorage.getItem('fontSize');//读取保存的字体大小
            if (savedFontSize) {//如果有保存的字体大小，则设置字体大小选择框的值
                document.getElementById('font-size').value = savedFontSize;
                document.body.style.fontSize = savedFontSize + 'px';
                document.getElementById('font-size-value').textContent = savedFontSize + 'px';
            }
        }
```
### 4.20 初始化用户界面
```javascript
// 初始化
        loadChats();//加载之前保存的聊天记录
        loadSettings();//加载保存的设置
        if (chats.length === 0) {//判断chats数组的长度是否为0，也就是检查是否有可恢复的聊天记录
            createNewChat();//如果没有可恢复的聊天记录，则创建一个新的聊天记录
        } else {//如果有可恢复的聊天记录，则切换到最后一个聊天记录
            switchChat(chats[chats.length - 1].id);
        }

        // 当用户在设置模态框外部区域点击时，模态框将调用 closeSettings() 函数被关闭，方便用户在不需要模态框时轻松关闭它，而无需寻找关闭按钮。
        window.onclick = function(event) {
            if (event.target == document.getElementById('settings-modal')) {
                closeSettings();
            }
        }
```

